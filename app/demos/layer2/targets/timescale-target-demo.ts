#!/usr/bin/env bun

/**
 * TimescaleDB Target Demo
 *
 * Demonstrates the TimescaleDB Market Data Writer actor.
 * Shows how to store data in TimescaleDB time-series database.
 */

import { getData, getError, isFailure, isSuccess } from "@qi/core/base";
import { createTimescaleMarketDataWriter } from "@qi/dp/actors/targets/timescale";
import type { CryptoMarketAnalytics, CryptoOHLCVData, CryptoPriceData } from "@qi/dp/dsl";

console.log("üóÑÔ∏è TimescaleDB Target Demo");
console.log("=".repeat(50));

async function demonstrateTimescaleTarget() {
  console.log("\nüìä Creating TimescaleDB Market Data Writer...");

  const timescaleWriter = createTimescaleMarketDataWriter({
    name: "demo-timescale-writer",
    connectionString:
      process.env.DATABASE_URL || "postgresql://postgres:password@localhost:5432/cryptodb",
    poolConfig: {
      max: 5,
      idleTimeoutMillis: 30000,
      connectionTimeoutMillis: 2000,
    },
    batchSize: 50,
    flushInterval: 2000,
    debug: true,
  });

  try {
    console.log("\nüöÄ Initializing TimescaleDB writer...");
    const initResult = await timescaleWriter.initialize();

    if (isSuccess(initResult)) {
      console.log("‚úÖ TimescaleDB writer initialized successfully");
    } else {
      const error = getError(initResult);
      console.log("‚ùå Initialization failed:", error?.message || "Unknown error");
      console.log("üí° Make sure TimescaleDB is running: docker-compose up timescaledb");
      return;
    }

    console.log("\nüíæ Testing DSL Storage Functions:");

    // Test 1: Store single price
    console.log("\n1Ô∏è‚É£ Storing single Bitcoin price...");

    const bitcoinPrice: CryptoPriceData = {
      coinId: "bitcoin",
      symbol: "BTC",
      name: "Bitcoin",
      usdPrice: 67500.45,
      btcPrice: 1.0,
      ethPrice: 19.2,
      marketCap: 1.33e12,
      volume24h: 28.5e9,
      change24h: 2.34,
      change7d: 8.67,
      lastUpdated: new Date(),
      source: "demo-generator",
      attribution: "Demo data for testing TimescaleDB target",
      exchangeId: "demo-exchange", // Added required field
    };

    const publishResult = await timescaleWriter.publishPrice(bitcoinPrice);

    if (isSuccess(publishResult)) {
      const publishData = getData(publishResult);
      if (publishData) {
        console.log("   ‚úÖ Price stored successfully:");
        console.log(`     üì® Message ID: ${publishData.messageId}`);
        console.log(`     üóÑÔ∏è Table: ${publishData.topic}`);
        console.log(`     üìä Size: ${publishData.size} row(s)`);
        console.log(`     ‚è∞ Timestamp: ${publishData.timestamp.toISOString()}`);
      }
    } else {
      const error = getError(publishResult);
      console.log(`   ‚ùå Price storage failed: ${error?.message || "Unknown error"}`);
    }

    // Test 2: Store multiple prices (batch)
    console.log("\n2Ô∏è‚É£ Storing multiple cryptocurrency prices...");

    const cryptoPrices: CryptoPriceData[] = [
      {
        coinId: "ethereum",
        symbol: "ETH",
        name: "Ethereum",
        usdPrice: 3520.12,
        btcPrice: 0.052,
        marketCap: 423e9,
        volume24h: 15.2e9,
        change24h: 1.89,
        change7d: 5.43,
        lastUpdated: new Date(),
        source: "demo-generator",
        attribution: "Demo data for testing TimescaleDB target",
        exchangeId: "demo-exchange", // Added required field
      },
      {
        coinId: "cardano",
        symbol: "ADA",
        name: "Cardano",
        usdPrice: 0.65,
        btcPrice: 0.0000096,
        marketCap: 23e9,
        volume24h: 890e6,
        change24h: -0.45,
        change7d: 3.21,
        lastUpdated: new Date(),
        source: "demo-generator",
        attribution: "Demo data for testing TimescaleDB target",
        exchangeId: "demo-exchange", // Added required field
      },
      {
        coinId: "polkadot",
        symbol: "DOT",
        name: "Polkadot",
        usdPrice: 8.45,
        btcPrice: 0.000125,
        marketCap: 12e9,
        volume24h: 456e6,
        change24h: 0.89,
        change7d: -1.23,
        lastUpdated: new Date(),
        source: "demo-generator",
        attribution: "Demo data for testing TimescaleDB target",
        exchangeId: "demo-exchange", // Added required field
      },
    ];

    const batchResult = await timescaleWriter.publishPrices(cryptoPrices);

    if (isSuccess(batchResult)) {
      const batchData = getData(batchResult);
      if (batchData) {
        console.log("   ‚úÖ Batch stored successfully:");
        console.log(`     üì® Total Messages: ${batchData.totalMessages}`);
        console.log(`     ‚úÖ Success Count: ${batchData.successCount}`);
        console.log(`     ‚ùå Failure Count: ${batchData.failureCount}`);
        console.log(`     üÜî Batch ID: ${batchData.batchId}`);
        console.log(`     ‚è±Ô∏è Processing Time: ${batchData.processingTime}ms`);
      }
    } else {
      const error = getError(batchResult);
      console.log(`   ‚ùå Batch storage failed: ${error?.message || "Unknown error"}`);
    }

    // Test 3: Store OHLCV data
    console.log("\n3Ô∏è‚É£ Storing Bitcoin OHLCV data...");

    const bitcoinOHLCV: CryptoOHLCVData = {
      coinId: "bitcoin",
      symbol: "BTC",
      timestamp: new Date(),
      open: 67200.0,
      high: 67800.0,
      low: 66500.0,
      close: 67500.45,
      volume: 890.5,
      timeframe: "1h",
      source: "demo-generator",
      attribution: "Demo OHLCV data for testing",
      exchangeId: "demo-exchange", // Added required field
    };

    const ohlcvResult = await timescaleWriter.publishOHLCV(bitcoinOHLCV);

    if (isSuccess(ohlcvResult)) {
      const ohlcvData = getData(ohlcvResult);
      if (ohlcvData) {
        console.log("   ‚úÖ OHLCV stored successfully:");
        console.log(`     üì® Message ID: ${ohlcvData.messageId}`);
        console.log(`     üóÑÔ∏è Table: ${ohlcvData.topic}`);
        console.log(`     üìä Timeframe: ${bitcoinOHLCV.timeframe}`);
        console.log(`     üîí Close Price: $${bitcoinOHLCV.close}`);
      }
    } else {
      const error = getError(ohlcvResult);
      console.log(`   ‚ùå OHLCV storage failed: ${error?.message || "Unknown error"}`);
    }

    // Test 4: Store multiple OHLCV data (batch)
    console.log("\n4Ô∏è‚É£ Storing multiple OHLCV records...");

    const ohlcvBatch: CryptoOHLCVData[] = Array.from({ length: 5 }, (_, i) => ({
      coinId: "bitcoin",
      symbol: "BTC",
      timestamp: new Date(Date.now() - (4 - i) * 3600000), // Hourly data
      open: 67000 + Math.random() * 1000,
      high: 67200 + Math.random() * 1000,
      low: 66800 + Math.random() * 800,
      close: 67100 + Math.random() * 900,
      volume: 800 + Math.random() * 200,
      timeframe: "1h",
      source: "demo-generator",
      attribution: "Demo historical OHLCV data",
      exchangeId: "demo-exchange", // Added required field
    }));

    const ohlcvBatchResult = await timescaleWriter.publishOHLCVBatch(ohlcvBatch);

    if (isSuccess(ohlcvBatchResult)) {
      const ohlcvBatchData = getData(ohlcvBatchResult);
      if (ohlcvBatchData) {
        console.log("   ‚úÖ OHLCV batch stored successfully:");
        console.log(`     üì® Total Records: ${ohlcvBatchData.totalMessages}`);
        console.log(`     ‚úÖ Success Count: ${ohlcvBatchData.successCount}`);
        console.log("     üïí Time Range: 5 hours of hourly data");
      }
    } else {
      const error = getError(ohlcvBatchResult);
      console.log(`   ‚ùå OHLCV batch storage failed: ${error?.message || "Unknown error"}`);
    }

    // Test 5: Store market analytics
    console.log("\n5Ô∏è‚É£ Storing market analytics...");

    const marketAnalytics: CryptoMarketAnalytics = {
      timestamp: new Date(),
      totalMarketCap: 2.45e12,
      totalVolume: 89.5e9,
      btcDominance: 54.2,
      ethDominance: 17.3,
      activeCryptocurrencies: 2835,
      markets: 8921,
      marketCapChange24h: 1.89,
      source: "demo-generator",
      attribution: "Demo analytics data for testing",
    };

    const analyticsResult = await timescaleWriter.publishAnalytics(marketAnalytics);

    if (isSuccess(analyticsResult)) {
      const analyticsData = getData(analyticsResult);
      if (analyticsData) {
        console.log("   ‚úÖ Analytics stored successfully:");
        console.log(`     üì® Message ID: ${analyticsData.messageId}`);
        console.log(`     üóÑÔ∏è Table: ${analyticsData.topic}`);
        console.log(
          `     üí∞ Total Market Cap: $${(marketAnalytics.totalMarketCap / 1e12).toFixed(2)}T`,
        );
        console.log(`     ‚Çø BTC Dominance: ${marketAnalytics.btcDominance}%`);
      }
    } else {
      const error = getError(analyticsResult);
      console.log(`   ‚ùå Analytics storage failed: ${error?.message || "Unknown error"}`);
    }

    // Test 6: Get publishing metrics
    console.log("\n6Ô∏è‚É£ Getting storage metrics...");

    const metricsResult = await timescaleWriter.getPublishingMetrics();

    if (isSuccess(metricsResult)) {
      const metrics = getData(metricsResult);
      if (metrics) {
        console.log("   üìä Storage Metrics:");
        console.log(`     üì® Total Messages: ${metrics.totalMessages}`);
        console.log(`     ‚úÖ Success Rate: ${(metrics.successRate * 100).toFixed(1)}%`);
        console.log(`     ‚è±Ô∏è Average Latency: ${metrics.averageLatency.toFixed(1)}ms`);
        console.log(`     ‚ùå Error Rate: ${(metrics.errorRate * 100).toFixed(1)}%`);
      }
    } else {
      const error = getError(metricsResult);
      console.log(`   ‚ùå Metrics fetch failed: ${error?.message || "Unknown error"}`);
    }

    // Test 7: Actor status
    console.log("\n7Ô∏è‚É£ Checking actor status...");
    const status = timescaleWriter.getStatus();
    console.log("   üîß Actor Status:");
    console.log(`     ‚úÖ Initialized: ${status.isInitialized}`);
    console.log(`     üîó Connected: ${status.isConnected}`);
    console.log(`     üíæ Has TimescaleDB Client: ${status.hasDrizzleClient}`);
    console.log(`     üì§ Total Publishes: ${status.totalPublishes}`);
    console.log(
      `     üïí Last Activity: ${status.lastActivity ? status.lastActivity.toISOString() : "None"}`,
    );
    console.log(`     ‚ùå Error Count: ${status.errorCount}`);
    console.log(`     ‚ö° Throughput: ${status.throughput.toFixed(2)} writes/sec`);

    // Test 8: Database-specific features
    console.log("\n8Ô∏è‚É£ Demonstrating TimescaleDB advantages...");
    console.log("   üí° TimescaleDB Features:");
    console.log("     üìà Automatic time-based partitioning (hypertables)");
    console.log("     üóúÔ∏è Compression for older data (90% space savings)");
    console.log("     üìä Fast time-series aggregations and analytics");
    console.log("     üîç SQL queries with time-series specific functions");
    console.log("     üìÖ Automatic retention policies");
    console.log("     üìà Excellent for technical analysis and backtesting");
  } catch (error) {
    console.error("üí• Demo failed with error:", error);
    const errorMessage = (error as Error)?.message;
    if (errorMessage?.includes("ECONNREFUSED") || errorMessage?.includes("connect")) {
      console.log("üí° Connection failed - make sure TimescaleDB is running:");
      console.log("   docker-compose up timescaledb");
    }
  } finally {
    console.log("\nüßπ Cleaning up...");
    const cleanupResult = await timescaleWriter.cleanup();

    if (isSuccess(cleanupResult)) {
      console.log("‚úÖ Cleanup completed successfully");
    } else {
      const error = getError(cleanupResult);
      console.log("‚ùå Cleanup failed:", error?.message || "Unknown error");
    }
  }

  console.log("\nüéâ TimescaleDB Target Demo completed!");
  console.log("üí° This demonstrates the unified DSL abstraction working with TimescaleDB storage");
  console.log("üîß The actor can store time-series data optimally for analytics");
  console.log("üìà Perfect for building historical data repositories and analytics pipelines");
  console.log("üîç Check TimescaleDB to see the stored time-series data!");
}

demonstrateTimescaleTarget().catch(console.error);
