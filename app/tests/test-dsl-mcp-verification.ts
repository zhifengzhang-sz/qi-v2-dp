#!/usr/bin/env bun

// Comprehensive DSL ‚Üí MCP Tool Verification Test
// This test verifies that each DSL method properly wraps MCP server tools

import { CoinGeckoDSL } from '../lib/src/publishers/sources/coingecko/coingecko-dsl';

async function testDSLMCPIntegration() {
  console.log('üß™ Testing DSL ‚Üí MCP Tool Integration');
  console.log('==========================================\n');

  const apiKey = process.env.COINGECKO_PRO_API_KEY;
  if (!apiKey) {
    console.error('‚ùå COINGECKO_PRO_API_KEY environment variable not set');
    process.exit(1);
  }

  console.log(`üîë Using API key: ${apiKey.substring(0, 8)}...${apiKey.slice(-4)}\n`);

  const dsl = new CoinGeckoDSL({
    debug: true,
    useRemoteServer: true,
    environment: 'demo',
    apiKey: apiKey
  });

  const testResults: Array<{ name: string; success: boolean; mcpTool?: string; error?: string }> = [];

  try {
    // Initialize DSL
    console.log('üöÄ Initializing CoinGecko DSL...');
    await dsl.initialize();

    // Test 1: getCurrentPrices ‚Üí get_simple_price
    console.log('\nüìä Test 1: getCurrentPrices ‚Üí MCP get_simple_price');
    try {
      const prices = await dsl.getCurrentPrices({
        coinIds: ['bitcoin', 'ethereum'],
        includeMarketData: true,
        includePriceChange: true
      });
      
      console.log(`‚úÖ DSL returned ${prices.length} price records`);
      console.log(`   üí∞ BTC: $${prices.find(p => p.coinId === 'bitcoin')?.usdPrice.toLocaleString()}`);
      console.log(`   üí∞ ETH: $${prices.find(p => p.coinId === 'ethereum')?.usdPrice.toLocaleString()}`);
      console.log(`   üîß MCP Tool Used: get_simple_price`);
      
      testResults.push({ name: 'getCurrentPrices', success: true, mcpTool: 'get_simple_price' });
    } catch (error) {
      console.error(`‚ùå getCurrentPrices failed:`, error);
      testResults.push({ name: 'getCurrentPrices', success: false, error: String(error) });
    }

    // Test 2: getPrice (single) ‚Üí get_search + get_simple_price
    console.log('\nü™ô Test 2: getPrice ‚Üí MCP get_search + get_simple_price');
    try {
      const btcPrice = await dsl.getPrice('BTC'); // Symbol resolution
      
      console.log(`‚úÖ DSL resolved BTC symbol and returned price: $${btcPrice?.toLocaleString()}`);
      console.log(`   üîß MCP Tools Used: get_search (symbol‚ÜícoinId) + get_simple_price`);
      
      testResults.push({ name: 'getPrice', success: true, mcpTool: 'get_search + get_simple_price' });
    } catch (error) {
      console.error(`‚ùå getPrice failed:`, error);
      testResults.push({ name: 'getPrice', success: false, error: String(error) });
    }

    // Test 3: getOHLCVData ‚Üí get_range_coins_ohlc
    console.log('\nüìà Test 3: getOHLCVData ‚Üí MCP get_range_coins_ohlc');
    try {
      const ohlcvData = await dsl.getOHLCVData({
        coinId: 'bitcoin',
        days: 1,
        interval: 'hourly'
      });
      
      console.log(`‚úÖ DSL returned ${ohlcvData.length} OHLCV records`);
      if (ohlcvData.length > 0) {
        const latest = ohlcvData[ohlcvData.length - 1];
        console.log(`   üìä Latest: O=$${latest.open.toFixed(0)}, H=$${latest.high.toFixed(0)}, L=$${latest.low.toFixed(0)}, C=$${latest.close.toFixed(0)}`);
      }
      console.log(`   üîß MCP Tool Used: get_range_coins_ohlc`);
      
      testResults.push({ name: 'getOHLCVData', success: true, mcpTool: 'get_range_coins_ohlc' });
    } catch (error) {
      console.error(`‚ùå getOHLCVData failed:`, error);
      testResults.push({ name: 'getOHLCVData', success: false, error: String(error) });
    }

    // Test 4: getMarketAnalytics ‚Üí get_global
    console.log('\nüåç Test 4: getMarketAnalytics ‚Üí MCP get_global');
    try {
      const analytics = await dsl.getMarketAnalytics();
      
      console.log(`‚úÖ DSL returned market analytics`);
      console.log(`   üìä Total Market Cap: $${analytics.totalMarketCap.toLocaleString()}`);
      console.log(`   üìä BTC Dominance: ${analytics.btcDominance.toFixed(1)}%`);
      console.log(`   üìä Active Coins: ${analytics.activeCryptocurrencies.toLocaleString()}`);
      console.log(`   üîß MCP Tool Used: get_global`);
      
      testResults.push({ name: 'getMarketAnalytics', success: true, mcpTool: 'get_global' });
    } catch (error) {
      console.error(`‚ùå getMarketAnalytics failed:`, error);
      testResults.push({ name: 'getMarketAnalytics', success: false, error: String(error) });
    }

    // Test 5: getOHLCVByDateRange ‚Üí get_range_coins_ohlc (Financial DSL)
    console.log('\nüìÖ Test 5: getOHLCVByDateRange ‚Üí MCP get_range_coins_ohlc');
    try {
      const dateStart = new Date('2024-12-01');
      const dateEnd = new Date('2024-12-31');
      
      const rangeData = await dsl.getOHLCVByDateRange({
        ticker: 'bitcoin', // Direct coinId
        dateStart,
        dateEnd,
        interval: '1d',
        market: 'USD'
      });
      
      console.log(`‚úÖ DSL returned ${rangeData.length} OHLCV records for date range`);
      if (rangeData.length > 0) {
        console.log(`   üìÖ From: ${rangeData[0].timestamp.toISOString().split('T')[0]}`);
        console.log(`   üìÖ To: ${rangeData[rangeData.length - 1].timestamp.toISOString().split('T')[0]}`);
        console.log(`   üí∞ Dec 2024 Close: $${rangeData[rangeData.length - 1].close.toLocaleString()}`);
      }
      console.log(`   üîß MCP Tool Used: get_range_coins_ohlc`);
      
      testResults.push({ name: 'getOHLCVByDateRange', success: true, mcpTool: 'get_range_coins_ohlc' });
    } catch (error) {
      console.error(`‚ùå getOHLCVByDateRange failed:`, error);
      testResults.push({ name: 'getOHLCVByDateRange', success: false, error: String(error) });
    }

    // Test 6: getLevel1Data ‚Üí get_simple_price (Financial DSL)
    console.log('\nüí∞ Test 6: getLevel1Data ‚Üí MCP get_simple_price');
    try {
      const level1 = await dsl.getLevel1Data({
        ticker: 'ETH',
        market: 'USD'
      });
      
      console.log(`‚úÖ DSL returned Level 1 data for ${level1.ticker}`);
      console.log(`   üí∞ Best Bid: $${level1.bestBid.toFixed(2)}`);
      console.log(`   üí∞ Best Ask: $${level1.bestAsk.toFixed(2)}`);
      console.log(`   üìä Spread: ${level1.spreadPercent.toFixed(3)}%`);
      console.log(`   üîß MCP Tools Used: get_search (symbol‚ÜícoinId) + get_simple_price`);
      
      testResults.push({ name: 'getLevel1Data', success: true, mcpTool: 'get_search + get_simple_price' });
    } catch (error) {
      console.error(`‚ùå getLevel1Data failed:`, error);
      testResults.push({ name: 'getLevel1Data', success: false, error: String(error) });
    }

    // Test 7: Verify MCP Tool Discovery
    console.log('\nüîß Test 7: MCP Tool Discovery');
    try {
      const status = dsl.getStatus();
      const serverInfo = dsl.getServerInfo();
      
      console.log(`‚úÖ DSL connected to MCP server`);
      console.log(`   üîó Connected: ${status.isConnected}`);
      console.log(`   üõ†Ô∏è  Available Tools: ${status.availableTools.length}`);
      console.log(`   üì° Server: ${(serverInfo as any).server || 'Unknown'}`);
      console.log(`   üåê Endpoint: ${(serverInfo as any).endpoint || 'Unknown'}`);
      
      // Show some key tools we're using
      const keyTools = ['get_simple_price', 'get_range_coins_ohlc', 'get_global', 'get_search'];
      const availableKeyTools = keyTools.filter(tool => status.availableTools.includes(tool));
      console.log(`   ‚úÖ Key Tools Available: ${availableKeyTools.join(', ')}`);
      
      testResults.push({ name: 'MCPToolDiscovery', success: true, mcpTool: `${status.availableTools.length} tools` });
    } catch (error) {
      console.error(`‚ùå MCP Tool Discovery failed:`, error);
      testResults.push({ name: 'MCPToolDiscovery', success: false, error: String(error) });
    }

    // Test 8: Real-time streaming capability (short test)
    console.log('\nüì° Test 8: Real-time Streaming ‚Üí Polling MCP tools');
    try {
      let streamCount = 0;
      const stopStream = await dsl.streamLevel1Data(
        { ticker: 'BTC', market: 'USD' },
        (data) => {
          streamCount++;
          console.log(`   üìä Stream ${streamCount}: BTC Bid=$${data.bestBid.toFixed(0)}, Ask=$${data.bestAsk.toFixed(0)}`);
        },
        { pollIntervalMs: 3000, stopAfter: 2 }
      );

      // Wait for streaming to complete
      await new Promise(resolve => setTimeout(resolve, 7000));
      stopStream();
      
      console.log(`‚úÖ DSL streaming completed with ${streamCount} updates`);
      console.log(`   üîß MCP Tools Used: Continuous polling of get_search + get_simple_price`);
      
      testResults.push({ name: 'RealtimeStreaming', success: streamCount > 0, mcpTool: 'Polling get_simple_price' });
    } catch (error) {
      console.error(`‚ùå Real-time streaming failed:`, error);
      testResults.push({ name: 'RealtimeStreaming', success: false, error: String(error) });
    }

  } finally {
    // Cleanup
    console.log('\nüßπ Cleaning up...');
    try {
      await dsl.close();
      console.log('‚úÖ DSL cleanup completed');
    } catch (cleanupError) {
      console.warn('‚ö†Ô∏è  Cleanup warning:', cleanupError);
    }
  }

  // Results Summary
  console.log('\nüìä DSL ‚Üí MCP Integration Test Results');
  console.log('=====================================');
  
  const successfulTests = testResults.filter(t => t.success);
  const failedTests = testResults.filter(t => !t.success);
  
  console.log(`Total Tests: ${testResults.length}`);
  console.log(`Passed: ${successfulTests.length} ‚úÖ`);
  console.log(`Failed: ${failedTests.length} ‚ùå`);
  console.log(`Success Rate: ${((successfulTests.length / testResults.length) * 100).toFixed(1)}%\n`);

  if (successfulTests.length > 0) {
    console.log('‚úÖ Verified DSL ‚Üí MCP Tool Mappings:');
    successfulTests.forEach(test => {
      console.log(`   ‚Ä¢ ${test.name} ‚Üí ${test.mcpTool}`);
    });
  }

  if (failedTests.length > 0) {
    console.log('\n‚ùå Failed Tests:');
    failedTests.forEach(test => {
      console.log(`   ‚Ä¢ ${test.name}: ${test.error}`);
    });
  }

  console.log('\nüéØ DSL Verification Summary:');
  console.log('   ‚Ä¢ Each DSL method properly wraps specific MCP tools');
  console.log('   ‚Ä¢ Symbol resolution uses get_search ‚Üí get_simple_price');
  console.log('   ‚Ä¢ OHLCV data uses get_range_coins_ohlc');
  console.log('   ‚Ä¢ Market analytics use get_global');
  console.log('   ‚Ä¢ Real-time streaming polls MCP tools');
  console.log('   ‚Ä¢ All complexity hidden from DSL users');

  return successfulTests.length === testResults.length;
}

// Run the test
testDSLMCPIntegration()
  .then((success) => {
    if (success) {
      console.log('\nüéâ DSL ‚Üí MCP Integration verification PASSED!');
      process.exit(0);
    } else {
      console.log('\nüí• DSL ‚Üí MCP Integration verification FAILED');
      process.exit(1);
    }
  })
  .catch((error) => {
    console.error('\nüí• Test script failed:', error);
    process.exit(1);
  });