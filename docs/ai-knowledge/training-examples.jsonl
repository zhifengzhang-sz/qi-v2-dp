{"prompt": "I want to add a new crypto data source like Binance API. How should I implement this?", "completion": "To add a new crypto data source following the Agent/MCP paradigm:\n\n1. **Check for Official MCP Server**: First check if Binance has an official MCP server at https://github.com/modelcontextprotocol/servers\n\n2. **If MCP Server Exists** (preferred):\n```typescript\n// Create MCP Wrapper\nexport class BinanceMCPWrapper {\n  constructor(private mcpClient: MCPClient) {}\n  \n  async getSpotPrices(symbols: string[]): Promise<BinancePrice[]> {\n    return await this.mcpClient.call('get_spot_prices', { symbols });\n  }\n}\n\n// Create DSL for domain operations\nexport class BinanceCryptoDSL {\n  constructor(private mcpWrapper: BinanceMCPWrapper) {}\n  \n  async getCurrentPrices(symbols: string[]): Promise<CryptoPrice[]> {\n    const binancePrices = await this.mcpWrapper.getSpotPrices(symbols);\n    return this.transformToCryptoFormat(binancePrices);\n  }\n}\n\n// Create Agent\nexport class BinanceDataAgent extends BaseAgent {\n  constructor(\n    config: AgentConfig,\n    mcpClient: MCPClient,\n    private dsl: BinanceCryptoDSL,\n    private mcpWrapper: BinanceMCPWrapper\n  ) {\n    super(config);\n  }\n}\n```\n\n3. **If No MCP Server** (fallback):\n```typescript\n// Create low-level client\nexport class BinanceAPIClient {\n  async getSpotPrices(symbols: string[]): Promise<BinancePrice[]> {\n    const response = await fetch('https://api.binance.com/api/v3/ticker/price');\n    return response.json();\n  }\n}\n\n// Use same DSL and Agent pattern, but with low-level client\nexport class BinanceCryptoDSL {\n  constructor(private client: BinanceAPIClient) {}\n  // ... same pattern\n}\n```\n\n4. **Integration**: Follow the DataAcquiringAgent pattern to publish to Redpanda streams.\n\n**Never**: Build direct API clients when MCP servers exist, return fake data, or create TODO stubs."}
{"prompt": "Can you help me create a market analysis agent that uses AI to analyze crypto trends?", "completion": "I'll create an AI-enhanced market analysis agent following the Agent/MCP paradigm:\n\n```typescript\nexport class MarketAnalysisAgent extends BaseAgent {\n  constructor(\n    config: AgentConfig,\n    mcpClient: MCPClient,\n    private dataDSL: CryptoFinancialDSL,\n    private analyticsDSL: MarketAnalyticsDSL,\n    private aiModel?: LanguageModel  // Optional AI\n  ) {\n    super(config);\n  }\n\n  async analyzeMarketTrends(\n    symbols: string[],\n    timeframe: string = '24h'\n  ): Promise<MarketAnalysis> {\n    // Step 1: Get real data (no AI needed)\n    const priceData = await this.dataDSL.getPriceHistory(symbols, timeframe);\n    const volumeData = await this.dataDSL.getVolumeData(symbols, timeframe);\n    \n    // Step 2: Calculate technical indicators (no AI needed)\n    const technicalData = await this.analyticsDSL.calculateIndicators({\n      prices: priceData,\n      indicators: ['sma', 'rsi', 'macd']\n    });\n    \n    // Step 3: AI analysis (optional)\n    if (this.aiModel) {\n      return await this.performAIAnalysis({\n        priceData,\n        volumeData, \n        technicalData\n      });\n    } else {\n      return await this.performRuleBasedAnalysis({\n        priceData,\n        volumeData,\n        technicalData\n      });\n    }\n  }\n\n  private async performAIAnalysis(data: MarketData): Promise<MarketAnalysis> {\n    const prompt = new PromptTemplate(`\n      Analyze this crypto market data and provide insights:\n      \n      Price Data: {priceData}\n      Volume Data: {volumeData}\n      Technical Indicators: {technicalData}\n      \n      Provide:\n      1. Trend direction and strength\n      2. Support/resistance levels\n      3. Volume analysis\n      4. Risk assessment\n      5. Key insights\n    `);\n    \n    const analysis = await this.processWithAI(prompt, data);\n    return this.parseAnalysisResult(analysis);\n  }\n\n  private async performRuleBasedAnalysis(data: MarketData): Promise<MarketAnalysis> {\n    // Rule-based analysis when no AI model\n    return {\n      trend: this.calculateTrendDirection(data.priceData),\n      strength: this.calculateTrendStrength(data.technicalData),\n      support: this.findSupportLevels(data.priceData),\n      resistance: this.findResistanceLevels(data.priceData),\n      riskLevel: this.assessRisk(data)\n    };\n  }\n}\n\n// Usage with different model configurations\nconst aiAgent = new MarketAnalysisAgent(\n  config,\n  mcpClient,\n  dataDSL,\n  analyticsDSL,\n  claude('claude-3-haiku')  // User chooses AI model\n);\n\nconst dataOnlyAgent = new MarketAnalysisAgent(\n  config,\n  mcpClient, \n  dataDSL,\n  analyticsDSL,\n  null  // No AI, pure rule-based analysis\n);\n```\n\n**Key Points:**\n- AI is optional - agent works with or without LLM\n- Data operations are separate from AI analysis\n- Uses real DSL operations, no fake data\n- User controls which AI model to use\n- Fast data processing + strategic AI usage"}
{"prompt": "I need to add error handling and retry logic to the crypto data pipeline. How should I implement this?", "completion": "I'll implement comprehensive error handling following the Agent/MCP patterns:\n\n```typescript\n// 1. Error Types for Domain-Specific Handling\nexport enum CryptoDataErrorType {\n  API_RATE_LIMIT = 'api_rate_limit',\n  API_UNAVAILABLE = 'api_unavailable', \n  DATA_VALIDATION = 'data_validation',\n  MCP_CONNECTION = 'mcp_connection',\n  DATABASE_ERROR = 'database_error',\n  STREAMING_ERROR = 'streaming_error'\n}\n\nexport class CryptoDataError extends Error {\n  constructor(\n    public type: CryptoDataErrorType,\n    message: string,\n    public retryable: boolean = true,\n    public retryAfter?: number\n  ) {\n    super(message);\n    this.name = 'CryptoDataError';\n  }\n}\n\n// 2. Retry Policy with Exponential Backoff\nexport class RetryPolicy {\n  constructor(\n    private maxRetries: number = 3,\n    private baseDelay: number = 1000,\n    private maxDelay: number = 30000\n  ) {}\n\n  async execute<T>(\n    operation: () => Promise<T>,\n    errorHandler?: (error: Error, attempt: number) => boolean\n  ): Promise<T> {\n    let lastError: Error;\n    \n    for (let attempt = 1; attempt <= this.maxRetries; attempt++) {\n      try {\n        return await operation();\n      } catch (error) {\n        lastError = error as Error;\n        \n        // Check if error is retryable\n        if (error instanceof CryptoDataError && !error.retryable) {\n          throw error;\n        }\n        \n        // Custom error handling\n        if (errorHandler && !errorHandler(error, attempt)) {\n          throw error;\n        }\n        \n        // Don't retry on last attempt\n        if (attempt === this.maxRetries) {\n          break;\n        }\n        \n        // Calculate delay with exponential backoff\n        const delay = Math.min(\n          this.baseDelay * Math.pow(2, attempt - 1),\n          this.maxDelay\n        );\n        \n        // Add jitter to prevent thundering herd\n        const jitter = Math.random() * 0.1 * delay;\n        await new Promise(resolve => setTimeout(resolve, delay + jitter));\n      }\n    }\n    \n    throw lastError;\n  }\n}\n\n// 3. Enhanced Data Acquiring Agent with Error Handling\nexport class DataAcquiringAgent extends BaseAgent {\n  private retryPolicy: RetryPolicy;\n  \n  constructor(\n    config: AgentConfig,\n    mcpClient: MCPClient,\n    private coinGeckoDSL: CoinGeckoFinancialDSL,\n    private streamingDSL: RedpandaStreamingDSL,\n    logger?: any\n  ) {\n    super(config, logger);\n    this.retryPolicy = new RetryPolicy(3, 1000, 30000);\n  }\n\n  async acquireAndPublishData(request: CryptoDataRequest): Promise<PublishedDataMetrics> {\n    const startTime = Date.now();\n    const metrics: PublishedDataMetrics = {\n      totalRecords: 0,\n      successfulPublishes: 0,\n      failedPublishes: 0,\n      averageLatency: 0,\n      topics: [],\n      timestamp: new Date()\n    };\n\n    try {\n      // Step 1: Acquire data with retry logic\n      const cryptoData = await this.retryPolicy.execute(\n        () => this.acquireDataFromSource(request),\n        (error, attempt) => {\n          this.logger?.warn(`Data acquisition attempt ${attempt} failed:`, error);\n          \n          if (error instanceof CryptoDataError) {\n            switch (error.type) {\n              case CryptoDataErrorType.API_RATE_LIMIT:\n                // Wait for rate limit reset if specified\n                if (error.retryAfter) {\n                  return true; // Retry after delay\n                }\n                break;\n              case CryptoDataErrorType.API_UNAVAILABLE:\n                return attempt < 3; // Retry up to 3 times\n              case CryptoDataErrorType.DATA_VALIDATION:\n                return false; // Don't retry validation errors\n            }\n          }\n          \n          return true; // Default: retry\n        }\n      );\n      \n      metrics.totalRecords = cryptoData.length;\n\n      // Step 2: Process data with error recovery\n      const processedData = await this.processDataWithErrorRecovery(cryptoData);\n\n      // Step 3: Publish with retry logic\n      const publishResults = await this.publishWithRetry(processedData, request.dataTypes);\n      \n      metrics.successfulPublishes = publishResults.successful;\n      metrics.failedPublishes = publishResults.failed;\n      metrics.topics = publishResults.topics;\n      metrics.averageLatency = Date.now() - startTime;\n\n      return metrics;\n\n    } catch (error) {\n      this.logger?.error('Data acquisition pipeline failed:', error);\n      metrics.failedPublishes = metrics.totalRecords;\n      \n      // Send error to monitoring system\n      await this.reportError(error, request);\n      \n      throw error;\n    }\n  }\n\n  private async acquireDataFromSource(request: CryptoDataRequest): Promise<any[]> {\n    try {\n      const allData: any[] = [];\n\n      for (const dataType of request.dataTypes) {\n        switch (dataType) {\n          case 'price':\n            const priceData = await this.coinGeckoDSL.getLatestPrices(request.symbols);\n            allData.push(...priceData.map(data => ({ ...data, type: 'price' })));\n            break;\n          case 'ohlcv':\n            const ohlcvData = await this.coinGeckoDSL.getOHLCVData(request.symbols);\n            allData.push(...ohlcvData.map(data => ({ ...data, type: 'ohlcv' })));\n            break;\n          case 'market_data':\n            const marketData = await this.coinGeckoDSL.getMarketData(request.symbols);\n            allData.push(...marketData.map(data => ({ ...data, type: 'market_data' })));\n            break;\n        }\n      }\n\n      if (allData.length === 0) {\n        throw new CryptoDataError(\n          CryptoDataErrorType.DATA_VALIDATION,\n          'No data retrieved from CoinGecko',\n          false\n        );\n      }\n\n      return allData;\n\n    } catch (error) {\n      if (error instanceof CryptoDataError) {\n        throw error;\n      }\n      \n      // Classify unknown errors\n      if (error.message?.includes('rate limit')) {\n        throw new CryptoDataError(\n          CryptoDataErrorType.API_RATE_LIMIT,\n          'CoinGecko API rate limit exceeded',\n          true,\n          60000 // Retry after 1 minute\n        );\n      }\n      \n      if (error.message?.includes('unavailable') || error.code === 'ECONNREFUSED') {\n        throw new CryptoDataError(\n          CryptoDataErrorType.API_UNAVAILABLE,\n          'CoinGecko API temporarily unavailable',\n          true\n        );\n      }\n      \n      throw new CryptoDataError(\n        CryptoDataErrorType.API_UNAVAILABLE,\n        `Unknown API error: ${error.message}`,\n        true\n      );\n    }\n  }\n\n  private async processDataWithErrorRecovery(rawData: any[]): Promise<any[]> {\n    const processedData = [];\n    const errors = [];\n\n    for (const record of rawData) {\n      try {\n        // Validate and process each record\n        const validatedRecord = await this.validateRecord(record);\n        processedData.push(validatedRecord);\n      } catch (error) {\n        errors.push({ record, error });\n        this.logger?.warn('Record processing failed:', error);\n      }\n    }\n\n    // Log processing statistics\n    this.logger?.info(`Processed ${processedData.length}/${rawData.length} records successfully`);\n    \n    if (errors.length > 0) {\n      this.logger?.warn(`${errors.length} records failed processing:`, errors);\n    }\n\n    return processedData;\n  }\n\n  private async publishWithRetry(\n    data: any[], \n    dataTypes: string[]\n  ): Promise<{ successful: number; failed: number; topics: string[] }> {\n    let successful = 0;\n    let failed = 0;\n    const topics: string[] = [];\n\n    const dataByType = this.groupDataByType(data);\n\n    for (const [type, records] of dataByType.entries()) {\n      try {\n        await this.retryPolicy.execute(async () => {\n          switch (type) {\n            case 'price':\n              await this.streamingDSL.publishPriceData(records);\n              topics.push('crypto-prices');\n              break;\n            case 'ohlcv':\n              await this.streamingDSL.publishOHLCVData(records);\n              topics.push('crypto-ohlcv');\n              break;\n            case 'market_data':\n              await this.streamingDSL.publishMarketData(records);\n              topics.push('crypto-analytics');\n              break;\n          }\n        });\n\n        successful += records.length;\n        this.logger?.info(`Published ${records.length} ${type} records successfully`);\n\n      } catch (error) {\n        failed += records.length;\n        this.logger?.error(`Failed to publish ${type} data after retries:`, error);\n        \n        // Store failed records for later retry\n        await this.storeFailedRecords(type, records, error);\n      }\n    }\n\n    return { successful, failed, topics };\n  }\n\n  private async reportError(error: Error, context: any): Promise<void> {\n    // Send to monitoring system (e.g., Sentry, DataDog)\n    const errorReport = {\n      timestamp: new Date(),\n      error: {\n        name: error.name,\n        message: error.message,\n        stack: error.stack,\n        type: error instanceof CryptoDataError ? error.type : 'unknown'\n      },\n      context,\n      agent: 'DataAcquiringAgent'\n    };\n    \n    // Could send to monitoring MCP server if available\n    this.logger?.error('Error report:', errorReport);\n  }\n\n  private async storeFailedRecords(type: string, records: any[], error: Error): Promise<void> {\n    // Store failed records in dead letter queue for manual processing\n    const failedBatch = {\n      timestamp: new Date(),\n      type,\n      records,\n      error: error.message,\n      retryCount: 0\n    };\n    \n    // Could use Redis or database to store failed records\n    this.logger?.warn('Stored failed records for later retry:', failedBatch);\n  }\n}\n```\n\n**Key Error Handling Features:**\n- Domain-specific error types with retry policies\n- Exponential backoff with jitter\n- Partial failure handling (process what you can)\n- Dead letter queue for failed records\n- Comprehensive logging and monitoring\n- Real implementations, no TODO stubs"}
{"prompt": "How do I properly configure the TimescaleDB MCP server for crypto financial data?", "completion": "I'll show you how to configure TimescaleDB with the official PostgreSQL MCP server for crypto financial data:\n\n```typescript\n// 1. MCP Server Configuration\nexport const timescaleDBMCPConfig = {\n  server: '@modelcontextprotocol/server-postgres',\n  transport: 'stdio',\n  args: [],\n  environment: {\n    // TimescaleDB connection (PostgreSQL compatible)\n    POSTGRES_HOST: 'localhost',\n    POSTGRES_PORT: '5432',\n    POSTGRES_DB: 'cryptodb',\n    POSTGRES_USER: 'postgres',\n    POSTGRES_PASSWORD: 'password',\n    \n    // Connection pool settings for high-frequency data\n    POSTGRES_MAX_CONNECTIONS: '20',\n    POSTGRES_IDLE_TIMEOUT: '30000',\n    POSTGRES_CONNECTION_TIMEOUT: '2000'\n  }\n};\n\n// 2. TimescaleDB MCP Wrapper\nexport class TimescaleDBMCPWrapper {\n  constructor(private mcpClient: MCPClient) {}\n\n  async executeQuery<T = any>(query: string, params?: any[]): Promise<T[]> {\n    return await this.mcpClient.call('execute_query', {\n      query,\n      parameters: params || []\n    });\n  }\n\n  async createHypertable(tableName: string, timeColumn: string): Promise<void> {\n    const query = `SELECT create_hypertable($1, $2, chunk_time_interval => INTERVAL '1 day')`;\n    await this.executeQuery(query, [tableName, timeColumn]);\n  }\n\n  async addCompressionPolicy(tableName: string, compressAfter: string): Promise<void> {\n    const query = `SELECT add_compression_policy($1, INTERVAL $2)`;\n    await this.executeQuery(query, [tableName, compressAfter]);\n  }\n\n  async addRetentionPolicy(tableName: string, retainFor: string): Promise<void> {\n    const query = `SELECT add_retention_policy($1, INTERVAL $2)`;\n    await this.executeQuery(query, [tableName, retainFor]);\n  }\n}\n\n// 3. TimescaleDB Financial DSL\nexport class TimescaleDBFinancialDSL {\n  constructor(private mcpWrapper: TimescaleDBMCPWrapper) {}\n\n  async initializeFinancialSchema(): Promise<void> {\n    // Create tables if not exist\n    await this.createCryptoPricesTable();\n    await this.createOHLCVTable();\n    await this.createMarketAnalyticsTable();\n    \n    // Setup TimescaleDB optimizations\n    await this.setupHypertables();\n    await this.setupCompressionPolicies();\n    await this.setupRetentionPolicies();\n    await this.createOptimizedIndexes();\n  }\n\n  private async createCryptoPricesTable(): Promise<void> {\n    const query = `\n      CREATE TABLE IF NOT EXISTS crypto_prices (\n        time TIMESTAMPTZ NOT NULL,\n        coin_id VARCHAR(50) NOT NULL,\n        symbol VARCHAR(20) NOT NULL,\n        usd_price NUMERIC(20,8),\n        btc_price NUMERIC(20,8),\n        market_cap NUMERIC(20,2),\n        volume_24h NUMERIC(20,2),\n        price_change_24h NUMERIC(10,6),\n        price_change_percentage_24h NUMERIC(10,6),\n        last_updated TIMESTAMPTZ DEFAULT NOW(),\n        PRIMARY KEY (coin_id, time)\n      )\n    `;\n    await this.mcpWrapper.executeQuery(query);\n  }\n\n  private async createOHLCVTable(): Promise<void> {\n    const query = `\n      CREATE TABLE IF NOT EXISTS ohlcv_data (\n        time TIMESTAMPTZ NOT NULL,\n        symbol VARCHAR(20) NOT NULL,\n        open NUMERIC(20,8) NOT NULL,\n        high NUMERIC(20,8) NOT NULL,\n        low NUMERIC(20,8) NOT NULL,\n        close NUMERIC(20,8) NOT NULL,\n        volume NUMERIC(20,2) NOT NULL,\n        timeframe VARCHAR(10) NOT NULL,\n        PRIMARY KEY (symbol, time, timeframe)\n      )\n    `;\n    await this.mcpWrapper.executeQuery(query);\n  }\n\n  private async setupHypertables(): Promise<void> {\n    try {\n      await this.mcpWrapper.createHypertable('crypto_prices', 'time');\n      await this.mcpWrapper.createHypertable('ohlcv_data', 'time');\n      console.log('✅ Hypertables created successfully');\n    } catch (error) {\n      // Tables might already be hypertables\n      console.log('ℹ️ Hypertables already exist or creation failed:', error.message);\n    }\n  }\n\n  private async setupCompressionPolicies(): Promise<void> {\n    await this.mcpWrapper.addCompressionPolicy('crypto_prices', '7 days');\n    await this.mcpWrapper.addCompressionPolicy('ohlcv_data', '30 days');\n    console.log('✅ Compression policies configured');\n  }\n\n  private async setupRetentionPolicies(): Promise<void> {\n    await this.mcpWrapper.addRetentionPolicy('crypto_prices', '2 years');\n    await this.mcpWrapper.addRetentionPolicy('ohlcv_data', '5 years');\n    console.log('✅ Retention policies configured');\n  }\n\n  private async createOptimizedIndexes(): Promise<void> {\n    const indexes = [\n      'CREATE INDEX IF NOT EXISTS crypto_prices_symbol_time_idx ON crypto_prices (symbol, time DESC)',\n      'CREATE INDEX IF NOT EXISTS crypto_prices_price_idx ON crypto_prices (usd_price) WHERE usd_price IS NOT NULL',\n      'CREATE INDEX IF NOT EXISTS ohlcv_symbol_timeframe_idx ON ohlcv_data (symbol, timeframe, time DESC)',\n      'CREATE INDEX IF NOT EXISTS ohlcv_volume_idx ON ohlcv_data (volume DESC)'\n    ];\n\n    for (const indexQuery of indexes) {\n      await this.mcpWrapper.executeQuery(indexQuery);\n    }\n    console.log('✅ Optimized indexes created');\n  }\n\n  async storeCryptoPrices(prices: CryptoPriceInput[]): Promise<void> {\n    if (prices.length === 0) return;\n\n    const query = `\n      INSERT INTO crypto_prices (\n        time, coin_id, symbol, usd_price, btc_price, market_cap, \n        volume_24h, price_change_24h, price_change_percentage_24h\n      )\n      VALUES ${prices.map((_, i) => `($${i * 8 + 1}, $${i * 8 + 2}, $${i * 8 + 3}, $${i * 8 + 4}, $${i * 8 + 5}, $${i * 8 + 6}, $${i * 8 + 7}, $${i * 8 + 8})`).join(', ')}\n      ON CONFLICT (coin_id, time) DO UPDATE SET\n        usd_price = EXCLUDED.usd_price,\n        btc_price = EXCLUDED.btc_price,\n        market_cap = EXCLUDED.market_cap,\n        volume_24h = EXCLUDED.volume_24h,\n        price_change_24h = EXCLUDED.price_change_24h,\n        price_change_percentage_24h = EXCLUDED.price_change_percentage_24h,\n        last_updated = NOW()\n    `;\n\n    const params = prices.flatMap(price => [\n      price.time,\n      price.coinId,\n      price.symbol,\n      price.usdPrice,\n      price.btcPrice,\n      price.marketCap,\n      price.volume24h,\n      price.priceChange24h\n    ]);\n\n    await this.mcpWrapper.executeQuery(query, params);\n  }\n\n  async getLatestPrices(symbols: string[]): Promise<CryptoPrice[]> {\n    const query = `\n      SELECT DISTINCT ON (symbol) \n        time, coin_id, symbol, usd_price, btc_price, \n        market_cap, volume_24h, price_change_24h, price_change_percentage_24h\n      FROM crypto_prices \n      WHERE symbol = ANY($1::text[])\n        AND time >= NOW() - INTERVAL '1 hour'\n      ORDER BY symbol, time DESC\n    `;\n    \n    return await this.mcpWrapper.executeQuery<CryptoPrice>(query, [symbols]);\n  }\n\n  async getPriceHistory(\n    symbol: string, \n    interval: string = '1h', \n    limit: number = 100\n  ): Promise<CryptoPrice[]> {\n    const query = `\n      SELECT \n        time_bucket($1::interval, time) as bucket,\n        symbol,\n        first(usd_price, time) as usd_price,\n        first(volume_24h, time) as volume_24h\n      FROM crypto_prices \n      WHERE symbol = $2\n        AND time >= NOW() - INTERVAL '7 days'\n      GROUP BY bucket, symbol\n      ORDER BY bucket DESC\n      LIMIT $3\n    `;\n    \n    return await this.mcpWrapper.executeQuery<CryptoPrice>(query, [interval, symbol, limit]);\n  }\n\n  async calculateMovingAverage(\n    symbol: string, \n    period: number = 20\n  ): Promise<MovingAverageResult[]> {\n    const query = `\n      SELECT \n        time,\n        symbol,\n        usd_price,\n        AVG(usd_price) OVER (\n          PARTITION BY symbol \n          ORDER BY time \n          ROWS BETWEEN $2 - 1 PRECEDING AND CURRENT ROW\n        ) as sma\n      FROM crypto_prices\n      WHERE symbol = $1\n        AND time >= NOW() - INTERVAL '30 days'\n      ORDER BY time DESC\n      LIMIT 1000\n    `;\n    \n    return await this.mcpWrapper.executeQuery<MovingAverageResult>(query, [symbol, period]);\n  }\n}\n\n// 4. Usage in Data Store Agent\nexport class DataStoreAgent extends BaseAgent {\n  constructor(\n    config: AgentConfig,\n    mcpClient: MCPClient,\n    private databaseDSL: TimescaleDBFinancialDSL\n  ) {\n    super(config);\n  }\n\n  async initialize(): Promise<void> {\n    // Initialize TimescaleDB schema and optimizations\n    await this.databaseDSL.initializeFinancialSchema();\n    console.log('✅ TimescaleDB configured for crypto financial data');\n  }\n\n  async storeMarketData(data: CryptoPriceInput[]): Promise<void> {\n    // Real database storage using PostgreSQL MCP server\n    await this.databaseDSL.storeCryptoPrices(data);\n  }\n}\n```\n\n**Docker Configuration for TimescaleDB:**\n```yaml\nversion: '3.8'\nservices:\n  timescaledb:\n    image: timescale/timescaledb:latest-pg14\n    environment:\n      POSTGRES_DB: cryptodb\n      POSTGRES_USER: postgres\n      POSTGRES_PASSWORD: password\n    ports:\n      - \"5432:5432\"\n    volumes:\n      - timescale_data:/var/lib/postgresql/data\n      - ./init.sql:/docker-entrypoint-initdb.d/init.sql\n    command: [\n      \"postgres\",\n      \"-c\", \"shared_preload_libraries=timescaledb\",\n      \"-c\", \"max_connections=100\",\n      \"-c\", \"work_mem=16MB\"\n    ]\n\nvolumes:\n  timescale_data:\n```\n\n**Key Features:**\n- Uses official PostgreSQL MCP server (TimescaleDB compatible)\n- Real database operations with proper financial precision\n- TimescaleDB-specific optimizations (hypertables, compression, retention)\n- High-performance indexes for crypto queries\n- Batch operations for streaming data\n- Time-series specific query patterns"}